const values=["A","K","Q","J","10","9","8","7","6","5","4","3","2"];chrome.runtime.onInstalled.addListener(()=>{chrome.storage.local.set({handsFolded:0});let r=[];for(let s=0;s<values.length;s++)for(let e=0;e<values.length;e++)s>e?r.push(values[e]+" "+values[s]+" o"):r.push(values[s]+" "+values[e]+" s");chrome.storage.local.set({range:r});let t=new Array(169).fill(!1);chrome.storage.local.set({fold:t})});const DEBUG=!0,AUTH_URL="https://dom-auth.onrender.com",HUB_HOST="dom-hub.onrender.com",MAX_RETRIES=100,INITIAL_BACKOFF_MS=1e3,MAX_BACKOFF_MS=1e4,AUTH_ERROR_BACKOFF_MS=6e4,QUEUE_CAP=100,RETRY_ALARM_NAME="hub-retry";function debugLog(...r){DEBUG&&console.log("[HubPublisher]",...r)}function generateUUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){const t=Math.random()*16|0;return(r=="x"?t:t&3|8).toString(16)})}async function getPublisherId(r){return new Promise(t=>{chrome.storage.local.get(["publisherIds"],s=>{let e=s.publisherIds||{};e[r]||(e[r]=generateUUID(),chrome.storage.local.set({publisherIds:e})),t(e[r])})})}async function fetchHubToken({roomId:r,role:t,publisherId:s}){try{const e=await fetch(`${AUTH_URL}/token`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({room:r,role:t,publisherId:s})});if(e.ok){const n=await e.json();return debugLog("Token fetched successfully, expires in",n.expiresInSeconds,"seconds"),{token:n.token,error:null,isAuthError:!1}}else return e.status===401?(console.error("[HubPublisher] Authentication failed (401)"),debugLog("Authentication failed (401)"),{token:null,error:"Authentication failed",isAuthError:!0}):(console.error(`[HubPublisher] Token fetch failed: HTTP ${e.status}`),debugLog("Token fetch failed with status:",e.status),{token:null,error:`HTTP ${e.status}`,isAuthError:!1})}catch(e){return console.error("[HubPublisher] Token fetch network error:",e.message),debugLog("Token fetch network error:",e.message),{token:null,error:e.message,isAuthError:!1}}}class HubPublisher{constructor(){this.ws=null,this.queue=[],this.retryCount=0,this.currentRoom=null,this.isConnecting=!1,this.authErrorBackoff=!1}extractRoomFromUrl(t){try{const e=t.split("?")[0].split("#")[0].replace(/\/$/,"").split("/"),n=e[e.length-1];return n&&n.trim()!==""?n:null}catch{return null}}async connect(t){if(t){if(this.currentRoom===t&&this.ws&&this.ws.readyState===WebSocket.OPEN){debugLog("Already connected to room:",t);return}if(this.currentRoom!==t&&(this.disconnect(),this.currentRoom=t,this.retryCount=0,this.authErrorBackoff=!1),!this.isConnecting&&!(this.ws&&(this.ws.readyState===WebSocket.CONNECTING||this.ws.readyState===WebSocket.OPEN))){this.isConnecting=!0,this.clearRetryAlarm();try{const s=await getPublisherId(t),e=await fetchHubToken({roomId:t,role:"pub",publisherId:s});if(!e.token){this.isConnecting=!1,e.isAuthError?(this.authErrorBackoff=!0,this.scheduleRetry(t,AUTH_ERROR_BACKOFF_MS)):this.scheduleRetry(t);return}this.authErrorBackoff=!1;const n=`wss://${HUB_HOST}/?room=${t}&role=pub&token=${e.token}`;this.ws=new WebSocket(n),this.ws.onopen=()=>{this.isConnecting=!1,this.retryCount=0,debugLog(`Connected to hub (room: ${t})`),this.flushQueue()},this.ws.onerror=o=>{console.error("[HubPublisher] WebSocket error:",o),debugLog("WebSocket error")},this.ws.onclose=o=>{this.isConnecting=!1,this.ws=null,debugLog("WebSocket closed, scheduling reconnect"),this.scheduleRetry(t)}}catch(s){debugLog("Connection error:",s.message),this.isConnecting=!1,this.scheduleRetry(t)}}}}scheduleRetry(t,s=null){if(this.retryCount>=MAX_RETRIES){debugLog(`Max retries (${MAX_RETRIES}) reached, giving up`),this.clearRetryAlarm();return}this.clearRetryAlarm(),this.retryCount++;let e;s!==null?e=s:e=Math.min(INITIAL_BACKOFF_MS*Math.pow(2,this.retryCount-1),MAX_BACKOFF_MS),debugLog(`Retry ${this.retryCount}/${MAX_RETRIES} in ${e}ms`),chrome.alarms.create(RETRY_ALARM_NAME,{when:Date.now()+e})}clearRetryAlarm(){chrome.alarms.clear(RETRY_ALARM_NAME)}disconnect(){if(this.clearRetryAlarm(),this.ws){try{this.ws.onclose=null,this.ws.close()}catch{}this.ws=null}this.isConnecting=!1}publish(t){try{const s=JSON.stringify(t);if(this.ws&&this.ws.readyState===WebSocket.OPEN)try{this.ws.send(s)}catch{this.enqueue(t)}else this.enqueue(t)}catch{}}enqueue(t){this.queue.push(t),this.queue.length>QUEUE_CAP&&this.queue.shift()}flushQueue(){for(;this.queue.length>0&&this.ws&&this.ws.readyState===WebSocket.OPEN;){const t=this.queue.shift();try{const s=JSON.stringify(t);this.ws.send(s)}catch{this.queue.unshift(t);break}}}}const hubPublisher=new HubPublisher;chrome.alarms.onAlarm.addListener(r=>{r.name===RETRY_ALARM_NAME&&hubPublisher.currentRoom&&(debugLog("Alarm fired, attempting reconnect"),hubPublisher.connect(hubPublisher.currentRoom))}),chrome.runtime.onMessage.addListener((r,t,s)=>{try{if(r.type==="HAND_DATA"){const e=r.data;if(e.url){const n=hubPublisher.extractRoomFromUrl(e.url);if(n){hubPublisher.connect(n);const o=({publisherId:i,pokerNowPlayerId:l})=>{const c={type:"hand",publisherId:i,pokerNowPlayerId:l||null,playerName:e.playerName||null,data:e,timestamp:Date.now()};hubPublisher.publish(c)};getPublisherId(n).then(i=>{o({publisherId:i,pokerNowPlayerId:e.playerId})}).catch(i=>{console.error("[HubPublisher] Failed to get publisher ID:",i),o({publisherId:generateUUID(),pokerNowPlayerId:e.playerId})})}}}}catch(e){console.error("[HubPublisher] Error handling message:",e)}return!1});
